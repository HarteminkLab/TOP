---
title: "Pipeline to obtain candidate binding sites and get DNase matrices and bins using DNase-seq bam files"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Pipeline to obtain candidate binding sites and get DNase matrices and bins using DNase-seq bam files}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Step 0: Download JASPAR motif database and install required software tools

* Download [JASPAR](http://jaspar.genereg.net) motif database

* Required softwares:

- [FIMO](http://meme-suite.org/doc/fimo.html?man_type=web) from MEME suite.
- [samtools](http://www.htslib.org)
- [bedtools](http://bedtools.readthedocs.io/en/latest/)
- [bwtools](https://github.com/CRG-Barcelona/bwtool/wiki)
- [UCSC command-line tools](http://hgdownload.cse.ucsc.edu/admin/exe/): `bedGraphToBigWig`, `bigWigAverageOverBed` 

### Install `TOP` R package
```{r installation, eval = FALSE}
install.packages("devtools")
library(devtools)
devtools::install_github("kevinlkx/TOP")
```

### Load `TOP` R package
```{r setup, eval = FALSE}
library(TOP)
```

## Step 1: find TF motif matches using [FIMO](http://meme-suite.org/doc/fimo.html?man_type=web)
This requires FIMO from MEME suite:
* FIMO instructions: http://meme-suite.org/doc/fimo.html?man_type=web
* MEME Suite installation: http://meme-suite.org/doc/install.html?man_type=web
You will need the FIMO output (fimo.txt) to get candidate TF binding sites. 

<!-- You can follow the instructions from [FIMO](http://meme-suite.org/doc/fimo.html?man_type=web), -->
<!-- or use this script: [fimo_jaspar_motif.sh](../inst/scripts/fimo_jaspar_motif.sh) -->

## Step 2: get candidate TF binding sites from FIMO output
<!-- * [sites_jaspar_motif.sh](sites_jaspar_motif.sh) -->
<!-- * [process_pwm_sites.R](process_pwm_sites.R) -->

```{r process_candidate_sites, eval = FALSE}
# file_fimo: the filename of FIMO result (fimo.txt)
# file_sites: the output filename of candidate sites.
# flank: size (bp) of flanking region on each side of motif. Default: 100.
# thresh_pValue: FIMO p-value threshold.
# Set "compute_mapability" to compute mapability for each window
# Set "filter_blacklist" to filter ENCODE blacklist regions
process_candidate_sites(file_fimo, file_sites, flank=100, thresh_pValue=1e-5)
```

## Step 3: count DNase-seq genome-wide cleavage, and output tagcount at each genome position in `Bigwig` format

* [genome_coverage_bamToBigwig.sh](genome_coverage_bamToBigwig.sh)

### Sort and index the BAM file, and then retrieve and print stats in the index file.
```{r bam_sort_index_stats, eval = FALSE}
# bam_file: input BAM file.
# dir_output: output directory.
# sort logical. If TRUE, sort (and index) the BAM file.
# stats logical. If TRUE, retrieve and print stats in the index file.
bam_sort_index_stats(bam_file, dir_output, sort=TRUE, stats=TRUE)
```

### Count the coverage of DNase-seq cuts along the genome, output in `Bigwig` format
```{r count_genome_coverage, eval = FALSE}
# bam_file: input BAM file.
# file_out: output file name.
# strand: strand ('+' or '-').
# file_genome_sizes: filename of genome sizes by chromosomes.
# output_format: Output format, 'Bigwig' (default) or 'bedGraph'.

count_genome_coverage(bam_file, file_out, strand='+', file_genome_sizes, output_format='Bigwig')

count_genome_coverage(bam_file, file_out, strand='-', file_genome_sizes, output_format='Bigwig')
```

## Step 4: match DNase-seq tagcount matrices for each motif

<!-- * [get_motif_count_matrices.sh](get_motif_count_matrices.sh) -->

### Match DNase tagcount matrices for candidate sites
```{r match_tagcount_sites, eval = FALSE}
# file_sites: filename for candidate sites
# file_dnase_tagcount_fwd: filename for DNase tagcount in forward strand
# file_dnase_tagcount_rev: filename for DNase tagcount in reverse strand
# file_dnase_matrix_fwd: filename for DNase tagcount matrix in forward strand
# file_dnase_matrix_rev: filename for DNase tagcount matrix in reverse strand
match_tagcount_sites(file_sites, file_dnase_tagcount_fwd, file_dnase_tagcount_rev, 
                     file_dnase_matrix_fwd, file_dnase_matrix_rev)
```

### Combine DNase tagcount matrices in both forward and reverse strands
```{r combine_dnase_counts, eval=FALSE}
# file_dnase_matrix_fwd: filename for DNase tagcount matrix in forward strand
# file_dnase_matrix_rev: filename for DNase tagcount matrix in reverse strand
dnase_cuts <- combine_dnase_counts(file_dnase_matrix_fwd, file_dnase_matrix_rev)
```

## Step 5: Normalize, bin DNaes data with `MILLIPEDE` binning scheme and tranform (log2 or asinh) DNase counts
```{r normalize_bin_dnase, eval=FALSE}
# dnase_tagcounts: DNase tagcount matrix
# file_idxstats: idxstats file generated by samtools
# type_bin: type of MILLIPEDE binning scheme (Default: 'M5').
# library_reference: DNase-seq reference library size (Default: 100 million)
# transform: log2 or asinh transform
dnase_bins <- normalize_bin_dnase(dnase_cuts, 
                                  file_idxstats, 
                                  type_bin='M5',
                                  library_reference=1e8, 
                                  transform='log2') 
```


