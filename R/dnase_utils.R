#' @title MILLIPEDE binning
#'
#' @param counts Counts matrix, rows are candidate sites,
#' columns are DNase or ATAC counts with 100bp flanks around motifs in forward and reverse strands
#' @param combine_strands Method to combine counts from M24 bins in both strands to M12 bins:
#' 'vertical' (default) or 'motif'.
#' @export
#'
millipede_binning <- function(counts, combine_strands=c('vertical', 'motif')) {

  combine_strands <- match.arg(combine_strands)

  counts <- as.matrix(counts)

  flank_LF1 <- 81:100
  flank_LF2 <- flank_LF1 - 20
  flank_LF3 <- flank_LF2 - 20
  flank_LF4 <- flank_LF3 - 20
  flank_LF5 <- flank_LF4 - 20
  flank_RF1 <- (ncol(counts)/2-99): (ncol(counts)/2-80)
  flank_RF2 <- flank_RF1 + 20
  flank_RF3 <- flank_RF2 + 20
  flank_RF4 <- flank_RF3 + 20
  flank_RF5 <- flank_RF4 + 20

  flank_LR1 <- ncol(counts)/2 + flank_LF1
  flank_LR2 <- ncol(counts)/2 + flank_LF2
  flank_LR3 <- ncol(counts)/2 + flank_LF3
  flank_LR4 <- ncol(counts)/2 + flank_LF4
  flank_LR5 <- ncol(counts)/2 + flank_LF5
  flank_RR1 <- ncol(counts)/2 + flank_RF1
  flank_RR2 <- ncol(counts)/2 + flank_RF2
  flank_RR3 <- ncol(counts)/2 + flank_RF3
  flank_RR4 <- ncol(counts)/2 + flank_RF4
  flank_RR5 <- ncol(counts)/2 + flank_RF5

  motif_LF <- 101: round(ncol(counts)/4)
  motif_RF <- (round(ncol(counts)/4)+1) : (ncol(counts)/2-100)
  motif_LR <- ncol(counts)/2 + motif_LF
  motif_RR <- ncol(counts)/2 + motif_RF

  M24 <- data.frame(
    flank_LF5 <- rowSums(counts[,flank_LF5]),
    flank_LF4 <- rowSums(counts[,flank_LF4]),
    flank_LF3 <- rowSums(counts[,flank_LF3]),
    flank_LF2 <- rowSums(counts[,flank_LF2]),
    flank_LF1 <- rowSums(counts[,flank_LF1]),

    motif_LF <- rowSums(counts[,motif_LF]),
    motif_RF <- rowSums(counts[,motif_RF]),

    flank_RF1 <- rowSums(counts[,flank_RF1]),
    flank_RF2 <- rowSums(counts[,flank_RF2]),
    flank_RF3 <- rowSums(counts[,flank_RF3]),
    flank_RF4 <- rowSums(counts[,flank_RF4]),
    flank_RF5 <- rowSums(counts[,flank_RF5]),

    flank_LR5 <- rowSums(counts[,flank_LR5]),
    flank_LR4 <- rowSums(counts[,flank_LR4]),
    flank_LR3 <- rowSums(counts[,flank_LR3]),
    flank_LR2 <- rowSums(counts[,flank_LR2]),
    flank_LR1 <- rowSums(counts[,flank_LR1]),

    motif_LR <- rowSums(counts[,motif_LR]),
    motif_RR <- rowSums(counts[,motif_RR]),

    flank_RR1 <- rowSums(counts[,flank_RR1]),
    flank_RR2 <- rowSums(counts[,flank_RR2]),
    flank_RR3 <- rowSums(counts[,flank_RR3]),
    flank_RR4 <- rowSums(counts[,flank_RR4]),
    flank_RR5 <- rowSums(counts[,flank_RR5])
    )

  if(combine_strands == 'vertical'){
    # vertical combine
    M12 <- M24[,c(1:12)] + M24[,c(13:24)]
  }else if (combine_strands == 'motif') {
    M12 <- M24[,c(1:12)] + M24[,c(24:13)]
  } else {
    stop('combine_strands needs to be vertical(default) or motif!')
  }

  colnames(M12) <- c('L5', 'L4', 'L3', 'L2', 'L1', 'motif_L', 'motif_R', 'R1', 'R2', 'R3', 'R4', 'R5')

  left2_sum <- rowSums(M12[,c(1,2)])
  left1_sum <- rowSums(M12[,c(3,4,5)])
  motif_sum <- rowSums(M12[,c(6,7)])
  right1_sum <- rowSums(M12[,c(8,9,10)])
  right2_sum <- rowSums(M12[,c(11,12)])

  M5 <- data.frame(left2_sum, left1_sum, motif_sum, right1_sum, right2_sum)

  M3 <- data.frame(left1_sum, motif_sum, right1_sum)

  M2 <- data.frame(left1_sum, right1_sum)

  M1 <- data.frame(left1_right1_sum = left1_sum + right1_sum)

  res <- list(M24 = M24,
              M12 = M12,
              M5 = M5,
              M3 = M3,
              M2 = M2,
              M1 = M1)

  return(res)

}


#' @title Normalize DNase or ATAC counts
#'
#' @description Normalize DNase or ATAC counts by library size scaling
#' @param counts count matrix
#' @param idxstats_file The idxstats file generated by samtools
#' @param ref.size Scale to reference library size
#'
#' @export
#'
normalize_counts <- function(counts,
                             idxstats_file,
                             ref.size=1e8) {

  ## Count total mapped reads (chr1:22)
  total_readsMapped <- get_total_reads(idxstats_file, select.chr = TRUE)

  ## Normalize (scale) read counts
  cat('Normalize (scale) to', ref.size / 1e6, 'million reads. \n')
  scaling_factor <- ref.size / total_readsMapped
  normalized_counts <- counts * scaling_factor

  return(normalized_counts)

}


#' @title Binning and transform count matrix
#'
#' @description Binning DNase (or ATAC) count matrix
#' using MILLIPEDE binning and then take asinh (or log2) transform
#' @param counts DNase (or ATAC) count matrix
#' @param bin.method MILLIPEDE binning scheme (Default: 'M5').
#' @param transform asinh or log2 transform
#'
#' @export
#'
bin_transform_counts <- function(counts,
                                 bin.method=c('M5','M1','M2','M3','M12','M24'),
                                 transform=c('asinh','log2')) {

  bin.method <- match.arg(bin.method)
  transform <- match.arg(transform)

  ## MILLIPEDE binning
  cat('Binning with MILLIPEDE', bin.method, 'binning... \n')
  bins.df <- millipede_binning(counts)[[bin.method]]

  if (transform == 'asinh') {
    cat('Perform asinh transform. \n')
    bins.df <- asinh(bins.df)
  } else if (transform == 'log2') {
    cat('Perform log2 transform. \n')
    bins.df <- log2(bins.df+1)
  }

  return(bins.df)

}


#' @title Normalize, binning and transform counts
#'
#' @description Normalize counts by library size,
#' bin using MILLIPEDE binning method and then take asinh or log2 transform
#'
#' @param count_matrix Counts matrix
#' @param idxstats_file The idxstats file generated by samtools
#' @param ref.size Scale to reference library size (Default: 1e8)
#' @param bin.method MILLIPEDE binning scheme (Default: 'M5').
#' @param transform asinh or log2 transform
#'
#' @export
#'
normalize_bin_transform_counts <- function(count_matrix,
                                           idxstats_file,
                                           ref.size=1e8,
                                           bin.method=c('M5','M1','M2','M3','M12','M24'),
                                           transform=c('asinh','log2')) {

  bin.method <- match.arg(bin.method)
  transform <- match.arg(transform)

  # Normalize (scale) read counts
  normalized_counts <- normalize_counts(count_matrix, idxstats_file, ref.size)

  ## MILLIPEDE binning and transform counts
  bins.df <- bin_transform_counts(normalized_counts, bin.method, transform)

  return(bins.df)

}


#' @title Merge counts, then normalize merged counts data.
#' @param counts_files Counts files
#' @param idxstats_files The idxstats files generated by samtools
#' @param ref.size Scale to reference library size
#'
#' @export
#'
merge_normalize_counts <- function(counts_files, idxstats_files, ref.size = 1e8){

  ## Load raw counts and sum over the replicates
  for (i in 1:length(counts_files)) {
    count_matrix <- readRDS(counts_files[i])
    if ( i == 1 ) {
      total_countmatrix <- count_matrix
    }else{
      total_countmatrix <- total_countmatrix + count_matrix
    }
  }

  ## Count total mapped reads
  total_readsMapped <- sum(sapply(idxstats_files, get_total_reads, select.chr = TRUE))

  ## Normalize (scale) read counts
  cat('Normalize (scale) to', ref.size / 1e6, 'million reads. \n')
  scaling_factor <- ref.size / total_readsMapped
  normalized_countmatrix <- total_countmatrix * scaling_factor

  return(normalized_countmatrix)

}


#' @title Count DNase-seq or ATAC-seq cleavage for a given genome.
#'
#' @param bam_file Sorted BAM file.
#' @param chrom_size_file File name of genome sizes by chromosomes.
#' @param outdir Output directory.
#' @param outname Output prefix.
#' @param bedtools_path Path to bedtools executable.
#' @param bedGraphToBigWig_path Path to UCSC bedGraphToBigWig executable.
#' @param bedSort_path Path to UCSC bedSort executable.
#' @importFrom data.table fread fwrite
#' @export
#'
count_genome_cuts <- function(bam_file,
                              chrom_size_file,
                              outdir,
                              outname,
                              bedtools_path='bedtools',
                              bedGraphToBigWig_path='bedGraphToBigWig',
                              bedSort_path='bedSort') {

  # Checking input arguments
  if ( Sys.which(bedtools_path) == "") {
    stop( 'bedtools could not be executed, set bedtools_path. \n' )
  }

  if ( Sys.which(bedGraphToBigWig_path) == "" ) {
    stop( 'bedGraphToBigWig could not be executed, set bedGraphToBigWig_path.\n' )
  }

  if(missing(outdir)){
    outdir <- dirname(bam_file)
  }

  if(!dir.exists(outdir)){
    dir.create(outdir, showWarnings = F, recursive = T)
  }

  if(missing(outname)){
    outname <- tools::file_path_sans_ext(basename(bam_file))
  }

  for (strand in c('+', '-')) {
    if (strand == '+') {
      out_file <- file.path(outdir, paste0(outname, '.fwd.genomecounts.bw'))
    } else if (strand == '-') {
      out_file <- file.path(outdir, paste0(outname, '.rev.genomecounts.bw'))
    }

    # Count 5' end cleavage and save as a .bedGraph file
    cat('Counting genome cleavage for', bam_file, strand, 'strand...\n')
    temp_file <- paste0(tools::file_path_sans_ext(out_file), '.bedGraph')
    cmd <- paste(bedtools_path, 'genomecov -bg -5', '-strand', strand,
                 '-ibam', bam_file, '>', temp_file)
    system(cmd)

    # sort .bedGraph file
    cat('Sorting bedGraph ...\n')
    if ( Sys.which(bedSort_path) == "" ) {
      system( paste("LC_COLLATE=C sort -k1,1 -k2,2n", temp_file, ">", temp_file ))
    }else{
      system( paste(bedSort_path, temp_file, temp_file) )
    }

    # Convert bedGraph to Bigwig format
    cat('Converting to Bigwig format ...\n')
    system(paste(bedGraphToBigWig_path, temp_file, chrom_size_file, out_file))

    file.remove(temp_file)
  }

}

#' @title Get count matrices around candidate sites.
#'
#' @param sites_file Filename for candidate sites
#' @param genomecount_dir Directory for genome counts
#' @param genomecount_name Filename prefix for genome counts
#' @param bwtool_path Path to bwtool executable.
#' @importFrom data.table fread fwrite
#' @export
#'
get_sites_counts <- function(sites_file,
                             genomecount_dir,
                             genomecount_name,
                             bwtool_path='bwtool') {

  if ( Sys.which(bwtool_path) == '' ) {
    stop( 'bwtool could not be executed, set bwtool_path!' )
  }

  genome_fwd_count_file <- file.path(genomecount_dir, paste0(genomecount_name, '.fwd.genomecounts.bw'))
  genome_rev_count_file <- file.path(genomecount_dir, paste0(genomecount_name, '.rev.genomecounts.bw'))

  fwd_matrix_file <- tempfile(pattern = "fwd.matrix")
  rev_matrix_file <- tempfile(pattern = "rev.matrix")

  # dir.create(dirname(fwd_matrix_file), showWarnings = F, recursive = T)
  cat('Extract counts around candidate sites ... \n')
  cmd <- paste('cut -f 1-4', sites_file, '|', bwtool_path, 'extract bed stdin',
               genome_fwd_count_file, fwd_matrix_file, '-fill=0 -decimals=0 -tabs')
  system(cmd)

  cmd <- paste('cut -f 1-4', sites_file, '|', bwtool_path, 'extract bed stdin',
               genome_rev_count_file, rev_matrix_file, '-fill=0 -decimals=0 -tabs')
  system(cmd)

  # Flip the counts generated from bwtool for motifs on the reverse strand
  rev_count_bwtool(sites_file, fwd_matrix_file, rev_matrix_file)

  # Combine counts on both strands
  sites.df <- fread(sites_file)
  fwd_counts <- fread(fwd_matrix_file)
  rev_counts <- fread(rev_matrix_file)

  combined_counts <- as.matrix(cbind(fwd_counts[,-c(1:4)], rev_counts[,-c(1:4)]))
  rownames(combined_counts) <- sites.df$name

  file.remove(fwd_matrix_file, rev_matrix_file)

  return(combined_counts)
}

#' @title Flip the counts generated from bwtool for motifs on the reverse (minus) strand
#'
#' @param sites_file Filename for candidate sites
#' @param fwd_matrix_file Filename for count matrix in forward strand
#' @param rev_matrix_file Filename for count matrix in reverse strand
#' @importFrom  data.table fread fwrite
#'
rev_count_bwtool <- function(sites_file, fwd_matrix_file, rev_matrix_file) {

  fwd_count.df <- fread(fwd_matrix_file)
  rev_count.df <- fread(rev_matrix_file)
  sites.df <- fread(sites_file)

  if(sum(sites.df[,2] != fwd_count.df[,2]) != 0) {
    stop('Sites do not match!')
  } else {
    # Extract the count values
    fwd_count.m <- as.matrix(fwd_count.df[, -c(1:5)])
    colnames(fwd_count.m) <- paste0('F', c(1:ncol(fwd_count.m)))
    rev_count.m <- as.matrix(rev_count.df[, -c(1:5)])
    colnames(rev_count.m) <- paste0('R', c(1:ncol(rev_count.m)))

    fwd_output <- fwd_count.m
    rev_output <- rev_count.m

    # For motifs match to the minus strand, flip the fwd and rev counts, and reverse the counts
    idx_minusStrand <- which(sites.df[,6] == '-')

    fwd_output[idx_minusStrand, ] <- t(apply(rev_count.m[idx_minusStrand, ], 1, rev))
    rev_output[idx_minusStrand, ] <- t(apply(fwd_count.m[idx_minusStrand, ], 1, rev))

    # Add the sites info to the first few columns
    fwd_count.df <- cbind(sites.df[,c(1:3,6)], fwd_output)
    rev_count.df <- cbind(sites.df[,c(1:3,6)], rev_output)

    fwrite(fwd_count.df, fwd_matrix_file, sep = ' ')
    fwrite(rev_count.df, rev_matrix_file, sep = ' ')

  }

}

